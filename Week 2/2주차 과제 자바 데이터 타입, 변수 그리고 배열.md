# 2주차 과제: 자바 데이터 타입, 변수 그리고 배열

### Primitive 종류와 값의 범위 그리고 기본 값

[Primitive Type System](https://www.notion.so/1ef201681c954f659e6ab548f398dc4e)

위 표는 primitive 자료형의 종류와 세부내용을 정리한 표입니다. 각 자료형의 형태와 메모리에 적재될 때 사용하는 바이트 크기, 표현할 수 있는 값의 범위와 특성을 나열했습니다. 이 때 자료형이 가질 수 있는 값의 범위는 컴퓨터가 데이터를 표현하기 위한 방법인 비트와 연관되어있습니다.

 사람은 10진수에 익숙합니다. 하지만 컴퓨터는 0과 1로 자료를 저장,표현합니다. 즉, 2진수를 통해 데이터를 표현하는 것이죠. 이를 비트(bit)라고 하며, 8개의 비트는 바이트(byte)가 됩니다. 그렇다면 int 자료형을 예시로 컴퓨터가 표현할 수 있는 범위가 어떻게 설정되는지를 확인해보겠습니다.

우선 int는 메모리 공간 4byte를 차지합니다. 1byte는 8bit이기 때문에 int는 총 32bit 공간 내에서 표현 가능한 데이터를 가지게 됩니다. 0,1이 들어갈 수 있는 자리가 총 32개이기 때문에 최대 $2^{32}$를 표현할 수 있습니다. 

하지만 우리가 표현하고자 하는 수가 항상 0보다 크진 않습니다. 따라서 우리는 음수를 표현하기 위해 가장 왼쪽에 있는 바이트를 부호 비트(MSB, Most Siginificant Bit)로 사용합니다.  만약 양수만 표현하고자 한다면 $2^{32}$까지 표현할 수 있겠지만, 음수도 표현해야 하므로 가장 첫번째 비트를 부호 비트로 사용하게 되어 표현할 수 있는 자리수가 줄어듭니다. 

따라서 정수, 실수 자료형들의 범위를 확인해보시면 메모리에 적재되기 위해 필요한 $2^{바이트 크기-1}$ 로 값의 범위를 가지는 것을 확인할 수 있습니다. 

---

### Primitive type & Reference type

 자바는 강력한 타입 시스템에 기반합니다. 그 이유는 타입 시스템이 변수에 담길 수 있는 값들을 제어함을 통해 컴파일 시점에 에러를 쉽게 발견할 수 있기 때문입니다. 

자바의 타입은 기본형(Primitive type)과 참조형(Reference) 두 가지로 나뉩니다. 아래는 각 자료형이 어떤 자료형으로 나눠지는 지를 간단히 나타낸 것입니다.

- **Primitive types**
    - boolean
    - numeric
        - byte, short, int, long, char
    - floating-type
        - float
        - double
- **Reference types**
    - Class
    - Interface
    - Array
    - String

기본형과 참조형 타입의 명백한 차이는 변수에 저장되는 값과 기본값의 존재여부입니다. 이 때 기본형은 실제 값이 stack에 저장되고 참조형은 Heap영역에 저장됩니다. 또한 기본형은 자료형별로 기본값을 가지지만 참조형은 그렇지 않다는 차이점이 있습니다.

---

### Literal

프로그램 내에서 사용되는 모든 값들을 지칭하며 숫자, 문자, 논리값 등 모든 값들이 포함됩니다.

- **Integer Literals**
    
    Integer Literal은 기본적으로 int 자료형을 가지며, long인 경우 L,l로 끝납니다. 이 l은 숫자 1과 구별하기 힘들기 때문에 L이 권장됩니다.
    
    > *The suffix `L` is preferred, because the letter `l` (ell) is often hard to distinguish from the digit `1` (one).*
    > 
    
    또한 java에서는 4가지 진법을 지원한다. 일반적인 10진법부터 0으로 시작하는 것을 통해 선언되는 8진법, 0X를 붙히는 16진법, 0b를 붙히는 2진법이 있다.
    
- **Floating-Point Literal**
    
    Floating-Point Literal은 기본적으로 double 자료형을 가지며, float의 경우 F,f로 끝납니다. 또한 선택적으로 double 자료형에도 d,D를 추가할 수 있습니다.
    
- **Boolean Literals**
    
    Boolean literal은 *true, false* 두 가지 종류의 값을 갖습니다. 
    
- **Character Literals**
    
    Character literal은 작은 따옴표 또는 \ 로 둘러싸여 있습니다.  . 또한 Character literal은 UTF-16 코드 단위만 나타낼 수 있습니다. 표현 가능한 범위는 `\u0000` ~`\uffff` 이며, 항상 char 자료형을 갖습니다.
    
- **String Literals**
    
    String literal은 0개 혹은 그 이상의 Character로 구성되어 있으며 “”를 통해 둘러싸여 있습니다. 항상 String 자료형을 가지며 String 인스턴스의 메모리 주소 레퍼런스 값을 갖습니다.
    
    - ***String interning***
        
        String literal은 Heap 영역의 String pool(since java 7)에 생성됩니다. String은 참조 자료형이기 때문에 생성될 때마다 인스턴스가 생성될 것이라고 예상하지만 String 문자열은 조금 다르게 동작합니다. 아래는 String 타입의 인스턴스를 비교하는 코드입니다. 
        
        ```java
        String stringLiteral = "String";
        String stringLiteral2 = "String";
        
        // Object type의 경우는 == 연산자가 값이 아닌 주소를 비교
        System.out.println(stringLiteral==stringLiteral2); // true
        
        System.out.println(System.identityHashCode(stringLiteral)); // 182460591
        System.out.println(System.identityHashCode(stringLiteral2)); // 182460591
        ```
        
        저희의 예상대로라면 String 클래스의 인스턴스는 각각 생성되어 할당된 메모리 주소값이 다른 것이 정상입니다. 그런데 둘의 메모리 주소값이 같군요. 어떻게 된 일일까요?
        
        이유는 바로 String이 한번 선언되어 할당되면 그 값을 변경할 수 없는 **Immutable한 특성**을 갖기 때문입니다. 즉 만약 “String”이라는 값을 갖는 String 인스턴스를 매번 생성하는 것은 같은 값을 중복해서 메모리에 올리는 메모리 낭비입니다. 따라서 String은 이전에 메모리에 저장된 값이 이후에 다시 배정되는 경우 새로운 메모리 공간을 확보하는 것이 아닌 원래 String pool에 존재하던 리터럴의 주소를 가리키도록 합니다. 이를 *String interning*이라고 합니다.
        
        ```java
        String whereIsHello = "hello";
        String whereIsHello2 = "hello";
        
        System.out.println(System.identityHashCode(whereIsHello)); // 1784662007
        System.out.println(System.identityHashCode(whereIsHello2)); // 1784662007
        
        whereIsHello = "I'm not hello";
        // 값이 변경되자 변수가 갖는 메모리 주소값이 변경
        // 1784662007 -> 997110508
        System.out.println(System.identityHashCode(whereIsHello)); // 997110508
        ```
        
        하지만 String literal이 생성되는 경우는 자동으로 interning을 진행하지만 String Object로 생성될 때에는 Interning 처리가 되지 않습니다. 따라서 아래처럼 String literal로 선언했을 때와 String Object로 선언된 인스턴스가 서로 다릅니다. 이때는 *intern()* 메서드를 통해 interning을 진행할 수 있습니다. 
        
        ```java
        
        String stringLiteral = "String"; // Literal
        String stringLiteralObj = new String("String"); // Object
        String stringLiteralInterned = new String("String").intern();
        
        System.out.println(stringLiteral==stringLiteralObj); // false
        System.out.println(stringLiteral==stringLiteralInterned); // true
        ```
        
        > → ****immutablity의 강점 
        
        -**** Security) 처음에 설정된 string이 중간에 바뀌게 되면, 이는 보안상의 문제가 발생할 수 있는 여지를 가지게 됩니다. 가령, 내가 비밀번호를 입력했는데, 프로그램이 돌아가면서 중간에 바뀐다? 이러면 문제가 심각하게 되는 것이죠. immutablity를 주입하고 이를 통해 프로그램 상에서 비밀번호가 바뀌면 에러가 발생하도록 함으로써, 보안상 강점을 획득할 수 있죠. 
        
        - Synchronization) 값이 한 번 정해지면 바뀌지 않는 다는 것은, 대략 함수형 프로그래밍 처럼 변수에 대해서 pipeline을 만들어서 처리하는 경우에, 병렬적으로 프로그래밍할 수 있도록 해줍니다. 만약 값이 중간에 바뀐다면 이 값으로 인해 다른 pipeline에 영향을 줄 수 있는데, 초기에 정해진 값이 이후에 바뀌지 않는다는 것이 확보된 상태면, 각 파이프라인들을 thread-safe하게 처리할 수 있거든요. 즉, 서로 다른 thread 간의 연산이 서로 독립적이라는 것이 확보된 상황이어서, 병렬적으로 파파팍 돌려버릴 수 있죠.
        
        *by* [https://frhyme.github.io/java/java_why_string_is_immutable/](https://frhyme.github.io/java/java_why_string_is_immutable/)
        > 

---