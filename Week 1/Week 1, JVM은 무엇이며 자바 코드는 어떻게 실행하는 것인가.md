# 1주차 과제: JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가

날짜: 2022년 3월 1일

### Java, WORA
Java의 WORA를 얘기하려면 먼저 C, C++ 언어가 컴파일 플랫폼과 타겟 플랫폼이 다르면 실행되지 못하는 플랫폼 종속성을 갖는다는 점을 얘기해야 한다. 물론 이를 크로스 컴파일(타겟 플랫폼에 맞춰 컴파일하는 것)을 통해 문제를 해결하긴 했지만 이 역시 실행하려는 플랫폼에 맞춰 컴파일을 해줘야 한다는 문제가 분명히 존재했다. 

따라서 Java는 이런 플랫폼 종속성을 해결하기 위해 바이트 코드라는 인다이렉션을 만들었다. 이를 통해 OS에 알맞는 JVM만 설치되어 있다면 플랫폼에 대한 의존성을 제거하여 항상 동일한 실행 환경을 제공한다. 이를 통해 C언어가 갖던 플랫폼 독립성의 문제를 해결할 수 있게 되었다.

‘*모든 소프트웨어 공학의 정답은 인다이렉션이다.’* 이라는 말이 있다. Java는 C언어가 갖던 플랫폼 독립성 문제를 J**VM이라는 인다이렉션의 생성**과 기계어와 인간의 **커뮤니케이션 툴을 바이트코드로 변경**하는 것을 통해 해결했다고 생각하면 이해하기가 쉬울 것이다.

> *자바 컴파일러는 C/C++ 등의 컴파일러처럼 고수준 언어를 기계어, 즉 직접적인 CPU 명령으로 변환하는 것이 아니라, 개발자가 이해하는 자바 언어를 JVM이 이해하는 자바 바이트코드로 번역한다. 따라서 자바 바이트코드는 플랫폼 의존적인 코드가 없어 JVM(정확하게 말하자면 같은 프로파일의 JRE)이 설치된 장비라면 CPU나 운영체제가 다르더라도 실행할 수 있다. (윈도우 PC에서 개발하여 컴파일한 클래스 파일을 리눅스 장비에서도 별다른 변경 없이 실행한다)*
>
> *from [JVM Internal](https://d2.naver.com/helloworld/1230)*

---

### 바이트코드란 무엇인가

앞서 바이트코드가 어떤 장점을 갖고 있는지 어떤 배경에서 탄생하게 되었는지를 확인했다. 바이트코드는 0과 1로 이루어진 이진 코드다. 하지만 이는 컴퓨터가 이해하고 실행할 수 있는 바이너리 코드와 달리 가상머신만  이해하는 코드다. 백문이 불여일견이다. 바이트코드가 어떻게 생겼는지 확인해보자. 아래는 바이트코드로 변환하기 전 Java 소스파일이다.

<img src="img/javacode.png">

위 소스코드를 `javap -v -p -s [클래스 파일명] > ShowByteCodeText.txt` 명령어를 통해 역어셈블링해본 결과다. 옵션은 추가정보를 출력하는 v, 모든 클래스와 멤버를 출력하는 p, 내부 타입을 표시하는 s를 사용했다. 

역어셈블링된 결과를 담은 텍스트 파일에는 클래스 파일의 위치와 수정시간, 어떤 소스코드에서부터 컴파일되었는지에 대한 메타데이터들이 명시되어있고, JVM이 운영체제에게 전달하는 바이너리 코드들이 작성되어있다. 

<img src="img/bytecode.png">

우리가 잊지 말아야할 것이 있다. 컴퓨터는 단 한순간도 소스코드와 바이트코드를 이해하지 못하며, 이해한 적도 없다. 컴파일러와 JVM을 통해 java코드 → 바이트코드 → 바이너리 코드로 변환되어 실행엔진이 바이트코드를 실행할 때 컴퓨터는 이해할 수 있다는 것을 잊지 말자.

---

### JVM이란 무엇인가? 또 어떻게 이뤄져 있는가?

JVM은 Java Virtual Machine의 약자로 자바 애플리케이션을 클래스 로더를 통해 읽어들이고 자바 API와 함께 실행하는 프로그램이다. Virtual Machine이라는 이름처럼 프로그램을 실행하기 위한 소프트웨어다. 

<img src="img/jvm.png">

1. **클래스 로더 시스템 (Class Loader)**
    
    클래스 로더는 실행에 필요한 클래스 목록들을 가져오는 역할이다. 위 과정은 런타임에서 최초로 클래스가 참조될 때 동적으로 로드, 링크 과정을 통해 이뤄진다. 아래는 자바 클래스 로더의 특징 4가지다.
    
    1. **계층 구조**
        
        클래스 로더끼리 부모-자식 관계를 이루어 계층 구조로 생성된다. 최상위 클래스 로더는 부트스트랩 클래스 로더(Bootstrap Class Loader)이다. 클래스 로더는 로드를 요청받았을 때 캐시, 상위 클래스 로더, 본인 순서로 클래스를 존재 여부를 탐색한다. 최상위 클래스 로더까지 탐색해도 없는 경우는 파일 시스템을 탐색한다. 이 때 만약 클래스가 없다면 발생하는 Exception이 우리가 흔히 보는 `ClassNotFoundException`이다.
        
    2. **위임 모델**
        
        계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 동작한다. 여기서도 인다이렉션 개념을 차용해 추상화가 되어있는 것을 확인할 수 있다. 클래스 로드 시 먼저 상위 클래스 로더를 확인하여 상위 클래스 로더에 있다면 해당 클래스를 사용하고, 없다면 로드를 요청받은 클래스 로더가 클래스를 로드한다. 
        
        클래스 로더들은 클래스를 로드한 후 보관하는 네임스페이스를 갖는데, 위에서 언급한 이미 존재하는지를 확인하기 위한 키로써 **FQCN(Fully Qualified Class Name)**을 사용한다.
        
    3. **가시성(visibility) 제한**
        
        하위 클래스 로더는 상위 클래스 로더의 클래스를 찾을 수 있지만, 상위 클래스 로더는 하위 클래스 로더의 클래스를 찾을 수 없다.
        
    4. **언로드 불가**
        
        클래스 로더는 클래스를 로드할 수는 있지만 언로드할 수는 없다. 언로드 대신, 현재 클래스 로더를 삭제하고 아예 새로운 클래스 로더를 생성하는 방법을 사용할 수 있다.
        
    
2. **런타임 데이터 영역 (Runtime Data Areas)**
    
    런타임 데이터 영역은 운영체제에서 실행되며 JVM이 할당받는 메모리 영역으로써 총 6개의 영역으로 나눠진다. 이 중 PC 레지스터, JVM 스택, 네이티브 메서드 스택은 스레드 갯수와 비례하여 생성되며, 나머지는 모든 스레드에 공유된다.
    
    <img src="img/runtime.png">
    
    1. **PC(Program Counter) Register**
        
        이름처럼 현재 수행중인 JVM 명령의 주소값을 가진다. 프로그램 카운터는 명령어 포인터라고도 불리며 모든 컴퓨터에서 공통적으로 실행될 명령어의 주소를 기억하는 곳을 의미한다. 
        
    2. **JVM Stack**
        
        JVM에 의해 추가(push), 제거(pop)되는 스택 프레임을 저장하는 곳이다. 스택 프레임은 JVM 내에서 **메서드가 수행될 때 마다 생성되는 구조체**로써 메서드 내부의 지역 변수 배열, 피연산자 스택(메서드의 실제 작업 공간), 현재 실행중인 메서드가 속한 클래스의 런타임 상수 풀에 대한 값을 가진다. 
        
    3. **Native Internal Threads**
        
        자바 외의 언어로 작성된 네이티브 코드를 위한 스택이다.
        
    4. **Method Area**
    JVM이 시작될 때 생성되며 클래스 로더를 통해 읽어 들인 클래스, 인터페이스에 대한 런타임 상수 풀, 필드, 메서드, Static 변수, 메서드의 바이트코드를 위한 공간이다. 
        - **Runtime Constant Pool**
            
            JVM 동작에서 가장 핵심적인 역할을 수행하는 곳으로 각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다.
            
    5. **Heap**
    인스턴스 또는 객체를 저장하는 공간으로 new 객체, 배열, 변수 등의 정보가 저장되며 가비지 컬렉션의 대상이다. 참조형 변수의 경우 인스턴스가 저장되는 것이 아니라 포인터가 저장된다. 

3. **실행 엔진 (Execute Engine)**

우리는 앞서 클래스 로더를 통해 클래스 정보를 가져온다는 것을 알았다. 또한 JVM 내의 런타임 데이터 영역에 자바 컴파일러에 의해 변환된 바이트코드가 위치한다는 것까지 확인했다. 이젠 프로그램을 실행해볼 차례다. 실행 엔진은 자바 바이트코드를 명령어 단위로 읽어서 실행한다. 하지만 위에서 바이트 코드는 컴퓨터가 이해하지 못하며 실행엔진을 통해서만 컴퓨터가 이해할 수 있다고 언급했다. 그렇다면 과연 실행엔진은 어떤 방식으로 바이너리 코드를 전달하는 것일까. 우선 실행엔진은 현재는 인터프리터 방식와 컴파일러 방식을 동시에 사용한다. Java는 인터프리터 언어다. 그런데 왜 갑자기 컴파일러를 동시에 사용했을까? 그 이유를 아래서 알아보자.

---

### JIT 컴파일러란 무엇이며 어떻게 동작하는지

자바는 바이트코드를 런타임에서 한줄씩 해석하고 실행하는 인터프리터 방식을 사용한다. 인터프리터는 소스코드를 기계어로 변환하는 컴파일을 구동 단계에서 수행하지 않고 런타임에서 한줄씩 행하기 때문에 해석은 빠르지만 실행 속도가 느리다. 반면 컴파일 방식은 런타임 실행 전에 소스코드를 한꺼번에 기계어로 변환한 뒤 실행하기 때문에 인터프리터 언어보다 속도가 빠르다. 이 때 실행속도의 향상을 위해 코드를 전체적으로 살펴보고 편집하는데 이를 최적화이라고 한다. 컴파일 방식은 이런 점 때문에 초기 구동 속도가 느리지만, 인터프리터가 갖는 반복에 의한 성능 이슈가 상대적으로 적다.

반면 자바는 바이트코드에 의한 기본적인 인터프리터 방식때문에 속도가 느린데에 더해 바이트코드로 변환하는 과정까지 포함되기 때문에 ‘자바는 느리다'라는 이슈들이 이전부터 존재했다. 따라서 자바는 이런 문제점을 해결하기 위해 Just-In-Time 컴파일러를 도입하여 현재는 인터프리터 방식과 컴파일 방식을 동시에 사용한다. 앞서 말했던 바이트코드에 대한 단점은 사실 자바 언어 특성상 WORA를 지원하기 때문에 필수불가결한 단점이다. 따라서 인터프리터 자체가 갖고 있는 불필요한 반복에 대한 이슈를 해결하기 위해 JIT 컴파일러가 등장했다. 

JIT 컴파일러는 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 해당 메서드를 더 이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는 방식이다. 네이티브 코드를 실행하는 것이 하나씩 인터프리팅하는 것보다 빠르고, 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 계속 빠르게 수행되게 된다.

위 과정에서 JIT 컴파일러는 실행 빈도에 따라 횟수가 낮으면 따뜻하다고 표현하고, 많이 수행되면 뜨겁다고 표현한다.  이 때 만약 동일한 코드가 동일한 변수 타입에 의해 실행되는 것을 모니터가 발견하게 되면, 해당 코드에서 미리 컴파일되었던 네이티브 코드를 내보내 해석의 반복에서 발생하는 코스트를 줄여준다.

---

### JDK와 JRE의 차이

<img src="img/jdk-jre.png">

JDK는 Java Development Kit의 약자로 자바를 개발하기 위한 통합 환경을 의미하며, JRE는 Java Runtime Environment의 약자로 자바의 실행환경을 의미한다. JRE는 Java API와 JVM으로 구성되어 있다. 

JRE는 기존 JDK에 포함되어 있으며 Java 9 버전부터는 JRE의 중복을 제거하기 위해 JDK만 제공하고 JRE는 제공하지 않는다.

---

### Reference

- [https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/](https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/)
    - [https://dongwoo.blog/2017/06/06/번역-저스트-인-타임jit-컴파일러-집중-코스/](https://dongwoo.blog/2017/06/06/%EB%B2%88%EC%97%AD-%EC%A0%80%EC%8A%A4%ED%8A%B8-%EC%9D%B8-%ED%83%80%EC%9E%84jit-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EC%A7%91%EC%A4%91-%EC%BD%94%EC%8A%A4/)
- [https://d2.naver.com/helloworld/1230](https://d2.naver.com/helloworld/1230)
