# 3주차: 연산자

이전 장에서는 자바의 타입 시스템, 리터럴, 변수를 학습했습니다. 이번 장에서는 이 녀석들을 선언하고 초기화한 뒤, 사용하는 법을 알아볼 예정입니다. 

연산자를 확인하기 전 연산이 무엇이고, 연산에는 어떤 것들이 필요한 지 가볍게 확인하겠습니다.

---

### 연산이란?

> *연산은 **수 혹은 식**을 **일정한 규칙**에 따라서 **계산**하는 것이다.*
> 

인용문처럼 연산에는 **수**와 일정한 **규칙**이 필요합니다. 이 때 연산의 대상이 되는 수의 역할을 **항 또는 피연산자(operand)**라고 하며, 항을 이용해 연산하도록 정해놓은 규칙이 기호로써 표기되는데 이것을 **연산자(operator)**라고 합니다. 

예를 들어 숫자를 연산하고 싶을 때는 산술 연산자를 통해 연산할 수 있으며, 필요한 항의 개수는 2개입니다. 

```java
2 + 2 = 4 
항 연산자 항
```

대충 연산자와 항이 무엇인지 이해가 되셨을까요? 우리가 하고 싶은 연산이 무엇인지에 따라 필요한 항의 개수와 필요한 규칙의 종류가 달라집니다. 먼저 항의 개수에 따라 단항 연산자, 이항 연산자, 삼항 연산자로 구분됩니다. 그리고 그 목적에 따라 연산자의 종류가 다시 나눠집니다. 이제 연산자의 종류를 확인해보겠습니다. 아래는 우리가 자바에서 사용할 수 있는 연산자의 종류입니다.

---

### 산술 연산자(이항)

더하기, 빼기, 곱하기, 나누기에 대한 기본 산술 연산자입니다. 복합 대입 연산자를 제외하고는 두 개의 항이 필요한 이항 연산자입니다. 

| Operator | Description |
| --- | --- |
| + | 가산 연산자, 문자열을 연결하는 데에도 사용됩니다 |
| - | 빼기 연산자 |
| * | 곱셈 연산자 |
| / | 나눗셈 연산자 |
| % | 나머지 연산자 |

---

### 단항 연산자

| Operator | Description |
| --- | --- |
| + | 가산 연산자, 문자열을 연결하는 데에도 사용 |
| - | 빼기 연산자 |
| ++X, --X | 피연산자 값을 1 증가 혹은 감소시키며, 연산자가 피연산자보다 앞에 있으므로 전위다.

이 때는 연산이 끝난 결과값이 연산결과값이다. |
| X++, X-- | 위와 동일하지만, 후위기 때문에 연산 이전의 값이 연산결과값이다. |
| ! | 피연산자의 논리값을 반대로 |

```java
// +, -
int isPlus = 1;
int isMinus = -isPlus;
System.out.println(isMinus); // isMinus is -1

// ++, -- (전위, 후위)
int result = +1;

System.out.println(result--); // result is 1
result--; 
System.out.println(result); // result is now 0

boolean success = false;
System.out.println(success); // false
System.out.println(!success); // true
```

---

### 관계 연산자

관계 연산자는 연산의 대상이 되는 피연산자가 다른 피연산자보다 크거나, 작거나, 같거나, 같지 않는지에 대한 여부를 판단하기 위해 사용되는 이항 연산자입니다.

| Operator | Description |
| --- | --- |
| == | 같음 |
| != | 같지 않음 |
| > | 초과 |
| >= | 크거나 같음 |
| < | 미만 |
| <= | 작거나 같음 |

---

### 비트 연산자

비트 단위로 논리 연산에 사용되는 연산자로 ~ 연산자를 제외하고는 모두 이항 연산자다.

| Operator | Description |
| --- | --- |
| & | 대응되는 비트가 모두 1이면 1을 반환 (비트 AND 연산) |
| | | 대응되는 비트 중에서 하나라도 1이면 1을 반환. (비트 OR 연산) |
| ^ | 대응되는 비트가 서로 다르면 1을 반환. (비트 XOR 연산) |
| ~ | 비트의 1의 보수 연산으로, 비트가 1이면 0, 0이면 1로 반전 (비트 NOT 연산) |
| << | 명시된 수만큼 비트들을 모두 왼쪽으로 이동. (Left shift 연산) |
| >> | 부호를 유지하고 지정된 수만큼 모두 오른쪽으로 이동. (Right shift 연산) |
| >>> | 명시된 수만큼 비트들을 모두 오른쪽으로 이동, 새로운 비트는 0으로 채움. (Unsigned right shift 연산) |

```java
System.out.println(Integer.toBinaryString(1 & 3)); // 0001 & 0011 -> 0001 = 1
System.out.println(Integer.toBinaryString(1 | 3)); // 0001 | 0011 -> 0011 = 11
System.out.println(Integer.toBinaryString(1 ^ 3)); // 0001 ^ 0011 -> 0010 = 10
System.out.println(Integer.toBinaryString(1 << 3)); // 0001 -> [0001]000 -> 1000
System.out.println(Integer.toBinaryString(8 >> 3)); // 1000 -> 1[000] -> 1
System.out.println(Integer.toBinaryString(16 >>> 3)); // 10000 -> 10[000] -> 10
System.out.println(Integer.toBinaryString(24 >>> 3)); // 11000 -> 11[000] -> 11
```

---

### 논리 연산자

논리합, 논리곱과 같은 부울식이 두 개가 존재할 때 조건부 AND, 조건부 OR 연산을 수행하는 이항 연산자입니다. 논리 연산자의 특징은 두 번째 연산자가 필요한 경우에만 수행된다는 것입니다. && 연산자는 둘다 참인 경우를, || 연산자는 둘 중 하나라도 참인 경우를 의미하기 때문에 첫 번째 연산자가 참의 결과를 갖는다면 두 번째 연산자는 실행되지 않습니다.

| Operator | Description |
| --- | --- |
| && | 조건부 AND |
| | | | 조건부 OR |

---

### 3항 연산자

유일하게 세 개의 피연산자를 사용하는 연산자입니다. 연산은 `A ? B : C` 로 작성됩니다. 의미는 *“A가 참인 경우 변수에 B를, 거짓인 경우는 A를 할당합니다”* 입니다.

```java
boolean someCondition = true;
String result = someCondition ? "assign true" : "assign false";
System.out.println(result); // assign true
```

---

### 할당 연산자

변수에 값을 대입하는 연산자로, 오른쪽에 있는 값을 왼쪽에 있는 피연산자에게 할당하는 연산을 수행하는 다항 연산자입니다. 기본형 변수에는 연산 결과나 값을 대입하고, 참조형 변수에는 주소값을 대입하는 연산자로 우선순위가 가장 낮습니다. 아래는 할당 연산자의 종류입니다.

| Operator | Description |
| --- | --- |
| = | 좌측 피연산자에 우측 연산자를 대입 |
| +=, -=, *=, /=, %= | 복합 대입 연산자로 단순 할당 연산자 산술 연산자를 결합해 복합 할당하는 연산자입니다.

ex. x+=1; → x=x+1;  |
| &=, |=, ^= | 비트 연산자와 결합한 형태입니다.

ex. |
| <<= | 좌측 피연산자를 우측 피연산자만큼 왼쪽 쉬프트하고, 결과값을 좌측 피연산자에 대입합니다. |
| >>= | 위와 반대 경우입니다. |
| >>>= | 좌측 피연산자를 오른쪽 피연산자만큼 부호에 상관없이 오른쪽 시프트하고, 결과값을 좌측 피연산자에 대입합니다. |

```java
// Simple Assignment Operator
int cadence = 0; // 값
int result = 1+2; // 연산 결과
Point originOne = new Point(23, 94); // 객체

```
